{
    "contents" : "#####################################\n# DATA PREPARATION\n#####################################\nlibrary(RODBC)\ndbhandle <- odbcConnect('Statistics', uid='reader', pwd='b@n@@n2014')\ntrain <- sqlQuery(dbhandle, \"SELECT DateStart, FutureProfitAndLoss, ProfitAndLoss, MaxInvoiceRank, ProvableIncome,\n  (case when ProvableIncome < 100 then 0 else 1 end) as HasProvableIncome,\n  (FutureProfitAndLoss - MaxInvoiceRank * 5 - 5) as CorrectedFPNL,\n  (case when FutureProfitAndLoss - MaxInvoiceRank * 5 > 5 then 0 else 1 end) as IsBad,\n  Amount,\n  IncomeDay,\n  Gender,\n  Age,\n  IncomeType,\n  MaritalStatus,\n  IncomeNetto,\n  BankName,\n  Margin,\n  Province,\n  DAY(DateEnd) as EndDay\n  FROM [Statistics].[dbo].[vw_STA_FullRiskManagement]\n  WHERE CountryCode = 'ES'\n  AND DatabaseId = 'C'\n  AND InvoiceRank = 1\n  AND (FutureProfitAndLoss < 0 OR MaxInvoiceRank >= 5)\n  AND DateEnd < '2014-07-19'\n  --AND IncomeType NOT LIKE '%social%'\n  AND IncomeType NOT LIKE '%flex%'\n  AND FutureProfitAndLoss IS NOT NULL\")\n\ntest <- sqlQuery(dbhandle, \"SELECT DateStart, FutureProfitAndLoss, ProfitAndLoss, MaxInvoiceRank, ProvableIncome,\n  (case when ProvableIncome < 100 then 0 else 1 end) as HasProvableIncome,\n  (FutureProfitAndLoss - MaxInvoiceRank * 5 - 5) as CorrectedFPNL,\n  (case when FutureProfitAndLoss - MaxInvoiceRank * 5 > 5 then 0 else 1 end) as IsBad,\n  Amount,\n  IncomeDay,\n  Gender,\n  Age,\n  IncomeType,\n  MaritalStatus,\n  IncomeNetto,\n  BankName,\n  Margin,\n  Province,\n  DAY(DateEnd) as EndDay\n  FROM [Statistics].[dbo].[vw_STA_FullRiskManagement]\n  WHERE CountryCode = 'ES'\n  AND DatabaseId = 'C'\n  AND InvoiceRank = 1\n  AND DateEnd < '2014-07-19'\n  -- AND IncomeType NOT LIKE '%social%'\n  AND IncomeType NOT LIKE '%flex%'\n  AND FutureProfitAndLoss IS NOT NULL\n  -- AND NOT (Amount <= 100 AND IncomeNetto < 600)\n  -- AND NOT (Amount = 150 AND IncomeNetto < 1200)\n  -- AND NOT (Amount = 200 AND IncomeNetto < 1600)\")\n\n\n# Add Amount to ProvableIncome variable\ntrain$atopi <- train$Amount / train$ProvableIncome\ntrain$atoi <- train$Amount / train$IncomeNetto\ntrain$IncomeDay[is.na(train$IncomeDay)] <- 30\ntrain$MarginRatio <- train$Margin / train$Amount\n\ntest$atopi <- test$Amount / test$ProvableIncome\ntest$atoi <- test$Amount / test$IncomeNetto\ntest$IncomeDay[is.na(test$IncomeDay)] <- 30\ntest$MarginRatio <- test$Margin / test$Amount\n\n# province default performance?\nlibrary(plyr)\nprov.table <- ddply(test, ~Province, summarize, mean=mean(FutureProfitAndLoss))\nprov.means <- prov.table$mean\nnames(prov.means) <- prov.table$Province\ntrain$ProvScore <- prov.means[train$Province]\ntest$ProvScore <- prov.means[test$Province]\n\n# get a vector of possible predictor variables\nallvars <- colnames(train)\nillegalvars <- c(\"DateStart\", \"Margin\", \"FutureProfitAndLoss\", \"ProfitAndLoss\", \"MaxInvoiceRank\", \"CorrectedFPNL\",\n  \"IsBad\", \"Province\")\npredictors <- allvars[!(allvars %in% illegalvars)]\n\n# get a list of all possible predictor combinations\n# WARNING: This will try removing max 4 predictors from the list to save time. \n# Do not include a lot of useless predictors. That is, do some manual research first.\npred.combs <- NULL\nfor (i in (length(predictors) - 4):length(predictors)) {\n  pred.combs <- c(pred.combs, as.list(data.frame(combn(predictors, i))))\n}\nlength(pred.combs)\n\n\nsum(test$CorrectedFPNL)\n##################################################################\n# Variable selection loop (simulated annealing)\n##################################################################\nlibrary(gbm)\nmaxdif <- -5000 # wild guess...\ntemperatures <- seq(1, 0, -0.015) * maxdif / log(0.4)\nloops <- length(temperatures)\nprofit.vector <- rep(0, loops)\nbest.formula.profit <- 0\nbest.formula <- NULL\nlast.formula.profit <- 0\nlast.formula.index <- as.integer(length(pred.combs) / 2)\n\nfor (i in 1:loops) {\n\n# Formula construction\n# pick a new candidate to determine its energy (=profit)\n# TODO: better candidate selection based on last.formula.index!!!!!!!!!!!!!!!!\ncandidate <- last.formula.index + sample(c(-1,1),1) * ceiling(rexp(1, rate=5/length(pred.combs)))\nif (candidate > length(pred.combs)) { candidate <- 2 * length(pred.combs) - candidate }\nif (candidate < 1) { candidate <- 2 - candidate }\ncandidate <- max(min(candidate, length(pred.combs)), 1)\n\n\nformula <- reformulate(as.character(pred.combs[candidate][[1]]), \"IsBad\")\n\n######################\n# MODEL BUILDING\n######################\nfit <- gbm(formula, data=train,\n  distribution=\"bernoulli\", n.trees = 200, shrinkage=0.08, train.fraction=0.5)\n#fit\n\nbest.iter <- gbm.perf(fit, method=\"test\")\n#best.iter\n\nsummary(fit)\n\n######################\n# MODEL EVALUATION\n######################\ntest$pred <- predict(fit, test, best.iter, type=\"response\")\n\n#library(pROC)\n\n#roccurve <- roc(test$IsBad, test$pred)\n#plot(roccurve)\n\n#cutoff <- 0.745\n# instead use a loop to get the optimum cutoff score\ncalcmprofit <- function(x) { if (x[1]) x[2] else 0 }\ncutofflist <- seq(0.72, 0.8, 0.002)\nbest.profit <- 0\nbest.cutoff <- 0\n\n# TODO: Make more efficient!!!!!!!!!\nfor(cutoff in cutofflist) {\n  test$accept <- (test$pred < cutoff)\n  \n  test$modelprofit <- apply(test[,c(\"accept\", \"CorrectedFPNL\")], 1, calcmprofit)\n  temp.profit <- sum(test$modelprofit)\n  if (temp.profit > best.profit) {\n    best.profit <- temp.profit\n    best.cutoff <- cutoff\n  }\n}\n\n# best.profit now contains the max profit attainable by the candidate formula.\n# Calculate the acceptance probability\nprofit.diff <- best.profit - last.formula.profit\naccept.prob <- 1\nif (profit.diff < 0) { accept.prob <- exp(profit.diff / temperatures[i]) }\n\n# if accepted, change state\nif (runif(1) < accept.prob) {\n  last.formula.profit <- best.profit\n  last.formula.index <- candidate\n}\n\nif (best.profit > best.formula.profit) {\n  best.formula.profit <- best.profit\n  best.formula <- formula\n  best.formula.gbm <- fit\n  best.formula.ntrees <- best.iter\n  best.formula.cutoff <- best.cutoff\n}\n\nprint(formula)\ncat(paste(\"T:\", temperatures[i], \"\\tcand:\", candidate, \"\\tcand cutoff:\", best.cutoff, \"\\tcand profit:\", best.profit, \n  \"\\tstate:\", last.formula.index, \"\\tstate profit:\", last.formula.profit, \"\\n\"))\ncat(\"Best:\\n\")\nprint(best.formula)\nprint(best.formula.profit)\nflush.console()\n\ntest$accept <- (test$pred < best.cutoff)  \ntest$modelprofit <- apply(test[,c(\"accept\", \"CorrectedFPNL\")], 1, calcmprofit)\n\nprofit.vector[i] <- last.formula.profit\n\n} # END TESTING LOOP\n#############################################################\n\n# Re-predict using the best found gbm model\ntest$pred <- predict(best.formula.gbm, test, best.formula.ntrees, type=\"response\")\ntest$accept <- (test$pred < best.formula.cutoff)  \ntest$modelprofit <- apply(test[,c(\"accept\", \"CorrectedFPNL\")], 1, calcmprofit)\n\nsum(test$CorrectedFPNL)\nsum(test$modelprofit)\nprofit.vector\n\n######################\n# SAVE RESULTS\n######################\nwrite.csv(test, \"spaincyv.csv\")\n\n######################\n# SAVE MODEL\n######################\nsql.export.gbm(best.formula.gbm, file=\"spaincyv_gbm.sql\", n.trees=best.formula.ntrees, id=\"OrderId\")\n\n######################\n# MODEL EXPLANATION\n######################\nlibrary(rpart)\nlibrary(rpart.plot)\nexplain.tree <- rpart(reformulate(predictors, response=\"accept\"),\n  data=test, method=\"class\")\n\nprp(explain.tree, extra=1)\n\nplot(profit.vector)\n\n\n######################\n# SIMULATED TEST SET\n######################\nsim <- test\nsim <- data.frame(lapply(sim, sample))\n# recalculate provscores etc!!!\nsim$atopi <- sim$Amount / sim$ProvableIncome\nsim$atoi <- sim$Amount / sim$IncomeNetto\nsim$MarginRatio <- sim$Margin / sim$Amount\nsim$ProvScore <- prov.means[sim$Province]\n\n# Re-predict using the best found gbm model\nsim$pred <- predict(best.formula.gbm, sim, best.formula.ntrees, type=\"response\")\nsim$accept <- (sim$pred < best.formula.cutoff)  \nsim$modelprofit <- apply(sim[,c(\"accept\", \"CorrectedFPNL\")], 1, calcmprofit)\n\nwrite.csv(sim, \"spaincyv_sim.csv\")\n",
    "created" : 1412628220776.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "93331875",
    "id" : "57A23A2A",
    "lastKnownWriteTime" : 1411976979,
    "path" : "~/Desktop/SpainCYV_AutoVarSelection.R",
    "project_path" : null,
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}